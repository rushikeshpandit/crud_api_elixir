defmodule CrudApiElixirTest.Router do
  # Bringing ExUnit's case module to scope and configure it to run
  # tests in this module concurrently with tests in other modules
  # https://hexdocs.pm/ex_unit/ExUnit.Case.html
  use ExUnit.Case, async: true

  # This makes the conn object avaiable in the scope of the tests,
  # which can be used to make the HTTP request
  # https://hexdocs.pm/plug/Plug.Test.html
  use Plug.Test

  # We call the Plug init/1 function with the options then store
  # returned options in a Module attribute opts.
  # Note: @ is module attribute unary operator
  # https://hexdocs.pm/elixir/main/Kernel.html#@/1
  # https://hexdocs.pm/plug/Plug.html#c:init/1
  @opts CrudApiElixir.Router.init([])


  # Create a test with the name "return ok"
  test "return ok" do
  	# Build a connection which is GET request on / url
    conn = conn(:get, "/")

    # Then call Plug.call/2 with the connection and options
    # https://hexdocs.pm/plug/Plug.html#c:call/2
    conn = CrudApiElixir.Router.call(conn, @opts)

    # Finally we are using the assert/2 function to check for the
    # correctness of the response
    # https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#assert/2
    assert conn.state == :sent
    assert conn.status == 200
    assert conn.resp_body == "OK"
  end

  describe "Posts" do
      # The setup callback is called before each test executes and the on_exit after each test is complete
      # We will use this hook to list all the mongo db collections and for each of
      # the collection to clear out the entire collection. This way for every test
      # case we will start from a clean slate
      setup do
        on_exit fn ->
          Mongo.show_collections(:mongo)
          |> Enum.each(
    		fn col -> Mongo.delete_many!(:mongo, col, %{})
    	end)
      end
  end

  test "POST /post should return ok" do
      # Assert that there are no elements in the db
      assert Mongo.find(:mongo, "Posts", %{}) |> Enum.count == 0

      # Make an API to call create a post
      conn = conn(:post, "/post", %{name: "Post 1", content: "Content of post"})
      conn = CrudApiElixir.Router.call(conn, @opts)

      # Checking that request was actually sent
      assert conn.state == :sent

      # Checking that response code was 200
      assert conn.status == 200

      # Asserting that response body was what we expected
      # Note: We are using pattern matching here to perform the assertion
      # The id is autogenerated by mongodb so we have not way of predicting it
      # therefore we just use _ to match to anything but expect it to exist
      assert %{
        "id" => _,
        "content" => "Content of post",
        "name" => "Post 1"
      } = Jason.decode!(conn.resp_body)

      # Assert that there is something in the db
      assert Mongo.find(:mongo, "Posts", %{}) |> Enum.count == 1
  end

  # A simple helper function that will help up quickly create
  # two posts in the databse
  def createPosts() do
    result = Mongo.insert_many!(:mongo, "Posts",[
      %{name: "Post 1", content: "Content 1"},
      %{name: "Post 2", content: "Content 2"},
    ])

   # The ids are BSON ObjectId which we are encoding to string for easier consumption
    result.inserted_ids |> Enum.map(fn id -> BSON.ObjectId.encode!(id) end)
  end

  test "GET /posts should fetch all the posts" do
    createPosts()

    conn = conn(:get, "/posts")
    conn = CrudApiElixir.Router.call(conn, @opts)

    assert conn.state == :sent
    assert conn.status == 200

    resp = Jason.decode!(conn.resp_body);

    assert Enum.count(resp) == 2
    assert %{
      "id" => _,
      "content" => "Content 1",
      "name" => "Post 1"
    } = Enum.at(resp, 0)
    assert %{
      "id" => _,
      "content" => "Content 2",
      "name" => "Post 2"
    } = Enum.at(resp, 1)
  end

  test "GET /post/:id should fetch a single post" do
    [id | _] = createPosts() # using pattern matching to get the first id

    conn = conn(:get, "/post/#{id}") # string interpolation
    conn = CrudApiElixir.Router.call(conn, @opts)

    assert conn.state == :sent
    assert conn.status == 200

    assert %{
      "id" => _,
      "content" => "Content 1",
      "name" => "Post 1"
    } = Jason.decode!(conn.resp_body)
  end

  test "PUT /post/:id should update a post" do
    [id | _] = createPosts()

    conn = conn(:put, "/post/#{id}", %{content: "Content 3"})
    conn = CrudApiElixir.Router.call(conn, @opts)

    assert conn.state == :sent
    assert conn.status == 200

    assert %{
      "id" => _,
      "content" => "Content 3",
      "name" => "Post 1"
    } = Jason.decode!(conn.resp_body)
  end

  test "DELETE /post/:id should delete a post" do
    [id | _] = createPosts()

    assert Mongo.find(:mongo, "Posts", %{}) |> Enum.count == 2

    conn = conn(:delete, "/post/#{id}", %{content: "Content 3"})
    conn = CrudApiElixir.Router.call(conn, @opts)

    assert conn.state == :sent
    assert conn.status == 200

    assert Mongo.find(:mongo, "Posts", %{}) |> Enum.count == 1
  end
end
